#
#   Written by:  Mark W Kiehl
#   http://mechatronicsolutionsllc.com/
#   http://www.savvysolutions.info/savvycodesolutions/
#


# Define the script version in terms of Semantic Versioning (SemVer)
# when Git or other versioning systems are not employed.
__version__ = "0.0.1"
from pathlib import Path
print("'" + Path(__file__).stem + ".py'  v" + __version__)

# v0.0.0    initial release
# v0.0.1    Added endpoings / and /api/calculator
# v0.0.0    Fixed several important references related to BASE_URL and GATEWAY_HOST.

"""

API Gateway for MCP Server via FastAPI & GCP Cloud Run 

This client script will access a Google Cloud Platform (GCP) API Gateway that serves a GCP Cloud Run service backend.
The Cloud Run service is a MCP Server based on FastAPI.  Access to the API Gateway is restricted by API Keys.   

The Windows OS batch file 'gcp_9_api_gateway.bat' automates the full deployment of a Google Cloud API Gateway
to secure a pre-deployed Cloud Run service using a restricted API Key.
The default limit is 50 API Keys per Google Cloud project / API Gateway (can be increased by request).

A YAML file 'openapi2-cloudrun.yaml' defines the OpenAPI spec needed to create the API Config.

# ---------------------------------------------------------------------------------------------------------
The YAML API Configuration File

The YAML file 'openapi2-cloudrun.yaml' (which follows the OpenAPI Specification, or Swagger) is the 
complete and formal definition of the API Configuration.

The final successful configuration highlighted several critical requirements and subtle syntax differences specific to the Google API Gateway, especially when integrating with a Cloud Run backend.

Here is a summary of the YAML file requirements and best practices:

1. Correct Path Translation is Essential (The Key Fix)
The most critical requirement is ensuring the API Gateway correctly forwards the full path of the client's request (e.g., /api/calculator) to the Cloud Run backend, instead of just the base URL.

You must include the path_translation field within the x-google-backend block for every single path (e.g., /, /ready, /api/calculator).

The correct value for Google API Gateway is path_translation: APPEND_PATH_TO_ADDRESS.

Using path_translation: CONSTANT_ADDRESS (the default when the field is omitted) or path_translation: APPEND_PATH (the correct syntax for Cloud Endpoints) will cause routing failures, often resulting in a 405 Method Not Allowed error, because the backend receives a request for its root path (/) instead of the intended route.

2. Precise POST Endpoint Configuration
For any endpoint that accepts a payload, such as your /api/calculator endpoint, the configuration must explicitly define the method and the body parameters.

The path must be defined under the explicit post: method key.

The request body is defined using a parameters block where the in field is set to body.

The schema nested under the body parameter must accurately reflect the expected JSON structure, including the data types (e.g., type: object, type: number with format: float, type: string) to ensure the Gateway can properly validate and pass the payload.

3. API Key Security Enforcement
API Key security must be defined globally and consistently.

The securityDefinitions block defines the API key itself, specifying that it is a type of apiKey found in the URL query (in: query) with the name key (?key=...).

The top-level security block enforces this rule globally across all endpoints in the YAML unless explicitly overridden. This ensures that every path requires a valid key to proceed.

4. Configuration Management Best Practices
To ensure reliable deployment and prevent conflicts with cached configurations:

Versioning: Always increment the info/version field (e.g., from 1.0.3 to 1.0.4) whenever deploying a change to the YAML. This is crucial for forcing the underlying Google Service Management layer to adopt the new configuration instead of using a stale one.

Clean Deployment: In cases of persistent, hard-to-diagnose errors (like the 405 you experienced), performing a full delete and redeploy of the API Gateway is the most effective way to eliminate environmental or cached configuration issues.


# ---------------------------------------------------------------------------------------------------------
PIP INSTALL:

google-cloud-storage
google-cloud-run
python-dotenv
rich
fastapi
uvicorn

"""

import requests
import os
from typing import Dict, Any
from time import sleep

# Update GATEWAY_HOST and API_KEY below with the output from execution of gcp_9_api_gateway.bat 
# Additional API_KEY strings can be generated by executing gcp_api_gateway_add_api_key.bat 

GATEWAY_HOST = "your-cloudrun-gateway-v0-0-0-tbd.uk.gateway.dev"
API_KEY = "your-39-char-api-key"

# -----------------------------------------


def run_check_ready_endpoint():
    """
    """
    # --- Test Case 1: Successful Call with API Key ---
    print("\n--- Test 1: Calling with API Key ---")
    try:

        endpoint = f"https://{GATEWAY_HOST}/ready"

        print(f"\nbase_url: {GATEWAY_HOST}")
        print(f"params: {params}\n")

        response = requests.get(endpoint, params=params)
        
        # API Gateway returns 401 if API key is invalid or not enabled for the service
        # Cloud Run returns 200/40x depending on your app logic
        if response.status_code == 200:
            print(f"SUCCESS (Code: {response.status_code}): {response.text}")
        else:
            # ERROR 404 Page not found  (gateway doesn't exist)
            # ERROR 401 Unauthorized (the API Key is completely invalid)
            # ERROR 403 Permission Denied (the API Key is valid, the service restriction (tying the key to your new API's service name) is what is failing).
            # ERROR 500: {"code":500,"message":"INTERNAL: Calling Google Service Control API failed with: 403 and body: \b\u0007\u0012_Permission 'servicemanagement.services.check' denied on service '\u003credacted_3rd_party_service\u003e'."}
            print(f"ERROR (Code: {response.status_code}): {response.text}")
            if not response.status_code == 200: raise Exception(f"Connection to API Gateway failed or was denied.")

    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")

    #return None

    # --- Test Case 2: Rejected Call without API Key ---
    print("\n--- Test 2: Calling WITHOUT API Key ---")
    try:
        # Do not include the 'params' dictionary
        response_unauth = requests.get(endpoint) 
        
        # API Gateway typically returns 401 Unauthorized or 403 Forbidden 
        # when the API key is missing due to the OpenAPI security requirement.
        if response_unauth.status_code in (401, 403):
            print(f"REJECTED (Expected Success - Code: {response_unauth.status_code}): Access correctly blocked.")
        else:
            print(f"UNEXPECTED RESPONSE (Code: {response_unauth.status_code}): {response_unauth.text}")
            
    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")


def get_server_status():
    """
    Checks the server status by requesting the OpenAPI specification 
    and retrieves the MCP server title, description, and version.
    """

    endpoint = f"https://{GATEWAY_HOST}/openapi.json"

    print(f"\n--- Checking Server Status ---")
    print(f"endpoint: {endpoint}")

    try:
        # Request the OpenAPI specification (FastAPI's documentation endpoint)
        response = requests.get(endpoint, params={'key': API_KEY})
        response.raise_for_status() # Raises an HTTPError for bad responses (4xx or 5xx)
        
        openapi_spec = response.json()
        # The metadata is stored under the 'info' key in the OpenAPI spec
        info = openapi_spec.get('info', {})

        print(f"--- MCP Server Metadata & Status ---")
        print(f"Server Status: UP (Confirmed via /openapi.json)")
        print(f"Title: {info.get('title', 'N/A')}")
        print(f"Description: {info.get('description', 'N/A')}")
        print(f"Version: {info.get('version', 'N/A')}")
        print("-" * 20)
        
    except requests.exceptions.ConnectionError:
        print("ERROR: Could not connect to the server.")
        #print("Please ensure your FastAPI server is running with: uvicorn mcp_server:app --reload")
    except requests.exceptions.HTTPError as e:
        print(f"ERROR: Failed to retrieve /openapi.json. Server responded with an error.")
        print(f"Details: {e}")
    except Exception as e:
        print(f"An unexpected error occurred during status check: {e}")


def run_calculator_tool(num1: float, num2: float, operation: str = "add"):
    """
    Calls the /api/calculator endpoint with structured input.

    :param num1: The first number.
    :param num2: The second number.
    :param operation: The operation to perform (e.g., 'add').
    """

    endpoint = f"https://{GATEWAY_HOST}/api/calculator"

    # Data structure must match the Pydantic 'ToolInput' model in the server
    payload: Dict[str, Any] = {
        "num1": num1,
        "num2": num2,
        "operation": operation
    }

    print(f"\n--- Executing Tool: {operation} ---")
    print(f"Input: {payload}")

    try:
        # Send the POST request with JSON payload
        response = requests.post(endpoint, json=payload, params={'key': API_KEY})
        
        # Check for successful response status codes (2xx)
        response.raise_for_status() 

        # Parse the JSON response, which matches the 'ToolOutput' model
        result_data = response.json()
        
        print(f"Output Message: {result_data.get('message')}")
        print(f"Output Result: {result_data.get('result')}")
        print("-" * 20)

    except requests.exceptions.RequestException as e:
        # Handle connection errors or bad server responses
        print(f"ERROR: Failed to execute tool call.")
        print(f"Details: {e}")
        if response is not None and response.text:
            # If server sent back detailed error (e.g., Pydantic validation error)
            print(f"Server Response Content: {response.text}")
        print("-" * 20)




if __name__ == "__main__":
    pass

    # Check the /ready endpoint
    run_check_ready_endpoint()

    # Check if the server is up
    sleep(1)
    get_server_status()
    
    # Run the simple calculator tool
    sleep(1)
    run_calculator_tool(num1=5.5, num2=10.2, operation="add")
    
    # Test with a different set of numbers
    #sleep(1)
    #run_calculator_tool(num1=100, num2=25, operation="add")

    # Test an unsupported operation to see the server's fallback response
    #sleep(1)
    #run_calculator_tool(num1=10, num2=3, operation="multiply")

    

